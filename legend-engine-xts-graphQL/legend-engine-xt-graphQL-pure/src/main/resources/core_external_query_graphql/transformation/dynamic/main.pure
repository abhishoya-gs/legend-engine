// Copyright 2021 Goldman Sachs
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

###Pure
import meta::external::query::graphQL::transformation::queryToPure::dynamic::expressions::field::*;
import meta::external::query::graphQL::transformation::queryToPure::dynamic::utility::*;
import meta::external::query::graphQL::transformation::queryToPure::dynamic::operators::eq::*;
import meta::external::query::graphQL::transformation::queryToPure::dynamic::operators::exists::*;
import meta::external::query::graphQL::transformation::queryToPure::dynamic::operators::in::*;
import meta::external::query::graphQL::transformation::queryToPure::dynamic::operators::contains::*;
import meta::external::query::graphQL::transformation::queryToPure::dynamic::operations::contains::*;
import meta::external::query::graphQL::transformation::queryToPure::dynamic::operations::exists::*;
import meta::external::query::graphQL::transformation::queryToPure::dynamic::operations::in::*;
import meta::external::query::graphQL::transformation::queryToPure::dynamic::operations::eq::*;
import meta::external::query::graphQL::transformation::queryToPure::dynamic::expressions::or::*;
import meta::external::query::graphQL::transformation::queryToPure::dynamic::expressions::and::*;
import meta::external::query::graphQL::metamodel::sdl::*;
import meta::external::query::graphQL::metamodel::sdl::value::*;
import meta::external::query::graphQL::metamodel::sdl::executable::*;
import meta::external::query::graphQL::transformation::queryToPure::dynamic::*;
import meta::external::query::graphQL::transformation::queryToPure::dynamic::metamodel::*;
import meta::pure::graphFetch::*;
import meta::pure::functions::lang::*;
import meta::pure::functions::multiplicity::*;

/*
  FINAL STATE HELPER FUNCTIONS
*/

function meta::external::query::graphQL::transformation::queryToPure::dynamic::traverseValue(v: Value[1], prefix: String[1], debug: DebugContext[1]): Node[*]
{
  $v->match([
    o : ObjectValue[1]  |   $o.fields->traverseObjectFields($prefix, ^$debug(space=$debug.space + ' ')),
    i : IntValue[1]     |   ^Literal(name = $prefix, type = Integer),
    s : StringValue[1]  |   ^Literal(name = $prefix, type = String),
    b : BooleanValue[1] |   ^Literal(name = $prefix, type = Boolean),
    f : FloatValue[1]   |   ^Literal(name = $prefix, type = Float),
    l : ListValue[1]    |   $l.values->fold({a,b | $b->concatenate($a->traverseValue($prefix + $b->size()->toString(), ^$debug(space = $debug.space + ' ')))}, []);,
    a : Any[1]          |   fail('Value of type ' + $a->type()->toOne()->toString() + ' not supported'); [];
  ]);
}

function meta::external::query::graphQL::transformation::queryToPure::dynamic::traverseObjectFields(obj: ObjectField[*], prefix: String[1], debug: DebugContext[1]): Node[*]
{
  let m = newMap(
    [
      ^Pair<String,Function<{ObjectField[1], String[1], DebugContext[1]->Node[*]}>>(first='_and',second=meta::external::query::graphQL::transformation::queryToPure::dynamic::expressions::and::processAnd_ObjectField_1__String_1__DebugContext_1__Node_MANY_),
      ^Pair<String,Function<{ObjectField[1], String[1], DebugContext[1]->Node[*]}>>(first='_or',second=meta::external::query::graphQL::transformation::queryToPure::dynamic::expressions::or::processOr_ObjectField_1__String_1__DebugContext_1__Node_MANY_),
      ^Pair<String,Function<{ObjectField[1], String[1], DebugContext[1]->Node[*]}>>(first='_eq',second=meta::external::query::graphQL::transformation::queryToPure::dynamic::operators::eq::processEq_ObjectField_1__String_1__DebugContext_1__Node_MANY_),
      ^Pair<String,Function<{ObjectField[1], String[1], DebugContext[1]->Node[*]}>>(first='_exists',second=meta::external::query::graphQL::transformation::queryToPure::dynamic::operators::exists::processExists_ObjectField_1__String_1__DebugContext_1__Node_MANY_),
      ^Pair<String,Function<{ObjectField[1], String[1], DebugContext[1]->Node[*]}>>(first='_in',second=meta::external::query::graphQL::transformation::queryToPure::dynamic::operators::in::processIn_ObjectField_1__String_1__DebugContext_1__Node_MANY_),
      ^Pair<String,Function<{ObjectField[1], String[1], DebugContext[1]->Node[*]}>>(first='_contains',second=meta::external::query::graphQL::transformation::queryToPure::dynamic::operators::contains::processContains_ObjectField_1__String_1__DebugContext_1__Node_MANY_)
    ]
  );
  $obj->fold({a,b | 
    $b->concatenate(
      $m->get($a.name)
        ->orElse(meta::external::query::graphQL::transformation::queryToPure::dynamic::expressions::field::processField_ObjectField_1__String_1__DebugContext_1__Node_MANY_)
        ->eval($a, $prefix, $debug)
    )}, []
  );
}

/*
  FINAL STATE HELPER FUNCTIONS
*/

Class meta::external::query::graphQL::transformation::queryToPure::dynamic::IntermediateClass
{
  vars: VariableExpression[*];
  valueSpecifications: ValueSpecification[*];
}

function meta::external::query::graphQL::transformation::queryToPure::dynamic::nodesToValueSpecification(nodes: Node[*], fieldNames: String[*], cl: Class<Any>[1], vars: VariableExpression[*], count: Integer[1]): IntermediateClass[*]
{
  $nodes->map(node |
    $node->match([
      f: FieldExpression[1]  |   processFieldExpression($f, $fieldNames, $cl, $vars, $count),
                                  
      a: AndExpression[1]     |   processAndExpression($a, $fieldNames, $cl, $vars, $count),
      
      o: OrExpression[1]      |   processOrExpression($o, $fieldNames, $cl, $vars, $count),
      
      e: EqOperator[1]        |   processEqOperator($e, $fieldNames, $cl, $vars, $count),

      i: InOperator[1]        |   processInOperator($i, $fieldNames, $cl, $vars, $count),

      ex: ExistsOperator[1]   |   processExistsOperator($ex, $fieldNames, $cl, $vars, $count),

      co: ContainsOperator[1] |   processContainsOperator($co, $fieldNames, $cl, $vars, $count),
      
      l: Literal[1]           |   let var = ^VariableExpression(multiplicity = PureOne, genericType = ^GenericType(rawType = $l.type), name = $l.name)->evaluateAndDeactivate();
                                  ^IntermediateClass(vars = $vars->concatenate($var), valueSpecifications = $var);
    ])
  );
}