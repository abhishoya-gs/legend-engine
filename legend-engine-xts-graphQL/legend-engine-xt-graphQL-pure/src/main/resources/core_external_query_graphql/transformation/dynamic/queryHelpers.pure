// Copyright 2021 Goldman Sachs
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

###Pure
import meta::external::query::graphQL::metamodel::sdl::*;
import meta::external::query::graphQL::metamodel::sdl::value::*;
import meta::external::query::graphQL::metamodel::sdl::executable::*;
import meta::external::query::graphQL::transformation::queryToPure::dynamic::*;
import meta::external::query::graphQL::transformation::queryToPure::dynamic::metamodel::*;
import meta::pure::graphFetch::*;
import meta::pure::functions::lang::*;

/*
  FINAL STATE HELPER FUNCTIONS
*/

function meta::external::query::graphQL::transformation::queryToPure::dynamic::traverseValue(v: Value[1], debug: DebugContext[1]): Node[*]
{
  $v->match([
    o : ObjectValue[1] | $o.values->traverseObjectFields(^$debug(space=$debug.space + ' ')),
    i : IntValue[1] | ^Literal(value = $i.value, type = Integer),
    s : StringValue[1] | ^Literal(value = $s.value, type = String),
    b : BooleanValue[1] | ^Literal(value = $b.value, type = Boolean),
    f : FloatValue[1] | ^Literal(value = $f.value,type = Float),
    l : ListValue[1] | $l.values->fold({a,b | $b->concatenate($a->traverseValue(^$debug(space = $debug.space + ' ')))}, []);
  ]);
}

function meta::external::query::graphQL::transformation::queryToPure::dynamic::traverseObjectFields(obj: ObjectField[*], debug: DebugContext[1]): Node[*]
{
  let m = newMap(
    [
      ^Pair<String,Function<{ObjectField[1], DebugContext[1]->Node[*]}>>(first='_and',second=meta::external::query::graphQL::transformation::queryToPure::dynamic::processAnd_ObjectField_1__DebugContext_1__Node_MANY_),
      ^Pair<String,Function<{ObjectField[1], DebugContext[1]->Node[*]}>>(first='_or',second=meta::external::query::graphQL::transformation::queryToPure::dynamic::processOr_ObjectField_1__DebugContext_1__Node_MANY_),
      ^Pair<String,Function<{ObjectField[1], DebugContext[1]->Node[*]}>>(first='_eq',second=meta::external::query::graphQL::transformation::queryToPure::dynamic::processEq_ObjectField_1__DebugContext_1__Node_MANY_)
    ]
  );
  $obj->map(o | $m->get($o.name)
      ->orElse(meta::external::query::graphQL::transformation::queryToPure::dynamic::processField_ObjectField_1__DebugContext_1__Node_MANY_)
      ->eval($o, $debug));
}

function meta::external::query::graphQL::transformation::queryToPure::dynamic::processAnd(o: ObjectField[1], debug: DebugContext[1]): Node[*]
{
  if($debug.debug, | println($debug.space+ 'AndExpression'), |[]);
  let value = $o.value->traverseValue(^$debug(space=$debug.space + ' '));
  
  assert($value->size() > 1, '_and should contain atleast two expressions');
  assert($value->filter(v | !$v->instanceOf(BooleanExpression))->size() == 0, 'One of the processed expressions in _and is not a valid boolean expression');
  
  let initialExpression = ^AndExpression(first=$value->at(0)->cast(@BooleanExpression), second=$value->at(1)->cast(@BooleanExpression));
  if($value->size()>2,
    | $value
      ->drop(2)
      ->fold({ a,b | ^AndExpression(first=$b, second=$a->cast(@BooleanExpression)) }, $initialExpression),
    | $initialExpression 
  );
}

function meta::external::query::graphQL::transformation::queryToPure::dynamic::processOr(o: ObjectField[1], debug: DebugContext[1]): Node[*]
{
  if($debug.debug, | println($debug.space + 'OrExpression'), |[]);
  let value = $o.value->traverseValue(^$debug(space=$debug.space + ' '));
  
  assert($value->size() > 1, '_or should contain atleast two expressions');
  assert($value->filter(v | !$v->instanceOf(BooleanExpression))->size() == 0, 'One of the processed expressions in _or is not a valid boolean expression');
  
  let initialExpression = ^OrExpression(first=$value->at(0)->cast(@BooleanExpression), second=$value->at(1)->cast(@BooleanExpression));
  if($value->size()>2,
    | $value
      ->drop(2)
      ->fold({ a,b | ^OrExpression(first=$b, second=$a->cast(@BooleanExpression)) }, $initialExpression),
    | $initialExpression 
  );
}

function meta::external::query::graphQL::transformation::queryToPure::dynamic::processField(o: ObjectField[1], debug: DebugContext[1]): Node[*]
{
  if($debug.debug, | println($debug.space + 'Field'), |[]);
  ^ColumnExpression(fieldName=$o.name, values = $o.value->traverseValue(^$debug(space=$debug.space + ' ')));
}

function meta::external::query::graphQL::transformation::queryToPure::dynamic::processEq(o: ObjectField[1], debug: DebugContext[1]): Node[*]
{
  if($debug.debug, | println($debug.space + 'EqOperator'), |[]);
  let value = $o.value->traverseValue(^$debug(space=$debug.space + ' '));
  
  assert($value->size() == 1, '_eq should contain only one value');
  assert($value->toOne()->instanceOf(Literal), '_eq value should be a literal');
  
  ^EqOperator(value=$o.value->traverseValue($debug)->toOne()->cast(@Literal));
}

function meta::external::query::graphQL::transformation::queryToPure::dynamic::nodesToString(node: Node[*], fieldName: String[1]): String[1]
{
 $node->match([
  c: ColumnExpression[1] | let newFieldName = if($fieldName != '', |$fieldName + '.' + $c.fieldName, |$c.fieldName); $c.values->nodesToString($newFieldName);,
  a: AndExpression[1] | 'and(' + $a.first->nodesToString($fieldName) + ',' + $a.second->nodesToString($fieldName) + ')',
  o: OrExpression[1] | 'or(' + $o.first->nodesToString($fieldName) + ',' + $o.second->nodesToString($fieldName) + ')',
  e: EqOperator[1] | 'equals(' + $fieldName + ',' + $e.value->nodesToString('') + ')',
  l: Literal[1] | $l.value->toString();
 ])
}

/*
  FINAL STATE HELPER FUNCTIONS
*/

function meta::external::query::graphQL::transformation::queryToPure::dynamic::nodesToValueSpecification(nodes: Node[*], fieldName: String[1], cl: Class<Any>[1]): ValueSpecification[*]
{
  $nodes->map(node |
    $node->match([
      c: ColumnExpression[1] | let newFieldName = if($fieldName != '', |$fieldName + '.' + $c.fieldName, |$c.fieldName); 
                              $c.values->nodesToValueSpecification($newFieldName,$cl)->evaluateAndDeactivate();,
      a: AndExpression[1] | createAnd(
                              $a.first->nodesToValueSpecification($fieldName,$cl)->toOne()->evaluateAndDeactivate(), 
                              $a.second->nodesToValueSpecification($fieldName,$cl)->toOne()->evaluateAndDeactivate()
                            ),
      o: OrExpression[1] | createOr(
                              $o.first->nodesToValueSpecification($fieldName,$cl)->toOne()->evaluateAndDeactivate(), 
                              $o.second->nodesToValueSpecification($fieldName,$cl)->toOne()->evaluateAndDeactivate()
                            ),
      e: EqOperator[1] | createEqual(
                            createProperty($cl->allProperties()->filter(p | $p.name == $fieldName)->toOne()->evaluateAndDeactivate(), $cl), 
                            $e.value->nodesToValueSpecification('', $cl)->toOne()->evaluateAndDeactivate()
                          );,
      l: Literal[1] | ^InstanceValue(multiplicity = PureOne, genericType = ^GenericType(rawType = $l.type), values = $l.value)->evaluateAndDeactivate();
    ])
  );
}

function meta::external::query::graphQL::transformation::queryToPure::dynamic::createAnd(left: ValueSpecification[1], right: ValueSpecification[1]): SimpleFunctionExpression[1]
{
  ^SimpleFunctionExpression(
    importGroup=system::imports::coreImport,
    func=meta::pure::functions::boolean::and_Boolean_1__Boolean_1__Boolean_1_,
    multiplicity=PureOne,
    parametersValues = [
      $left,
      $right
    ],
    genericType=^GenericType(rawType=Boolean)
  )->evaluateAndDeactivate();
}

function meta::external::query::graphQL::transformation::queryToPure::dynamic::createOr(left: ValueSpecification[1], right: ValueSpecification[1]): SimpleFunctionExpression[1]
{
  ^SimpleFunctionExpression(
    importGroup=system::imports::coreImport,
    func=meta::pure::functions::boolean::or_Boolean_1__Boolean_1__Boolean_1_,  
    multiplicity=PureOne,
    parametersValues = [
      $left,
      $right
    ],
    genericType=^GenericType(rawType=Boolean)
  )->evaluateAndDeactivate();
}

function meta::external::query::graphQL::transformation::queryToPure::dynamic::createEqual(left: ValueSpecification[1], right: ValueSpecification[1]): SimpleFunctionExpression[1]
{
  ^SimpleFunctionExpression(
    importGroup=system::imports::coreImport,
    func=meta::pure::functions::boolean::equal_Any_MANY__Any_MANY__Boolean_1_,
    multiplicity=PureOne,
    parametersValues = [
      $left,
      $right
    ],
    genericType=^GenericType(rawType=Boolean)
  )->evaluateAndDeactivate();
}

function meta::external::query::graphQL::transformation::queryToPure::dynamic::createProperty(p: AbstractProperty<Any>[1], cl: Class<Any>[1]): SimpleFunctionExpression[1]
{
  ^SimpleFunctionExpression(
    importGroup=system::imports::coreImport,
    func=$p,
    multiplicity=PureOne,
    parametersValues = [
      ^VariableExpression(multiplicity=PureOne, genericType=^GenericType(rawType=$cl), name='p')
    ],
    genericType=$p.genericType
  )->evaluateAndDeactivate();
}
