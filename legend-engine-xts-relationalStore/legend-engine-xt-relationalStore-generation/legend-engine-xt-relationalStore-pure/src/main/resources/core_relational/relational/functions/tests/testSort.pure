// Copyright 2021 Goldman Sachs
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import meta::pure::graphFetch::execution::*;
import meta::relational::mapping::*;
import meta::relational::tests::model::simple::*;
import meta::relational::tests::*;
import meta::external::store::relational::tests::*;
import meta::pure::profiles::*;
import meta::pure::executionPlan::toString::*;

function <<test.Test>> meta::relational::tests::query::sort::testSortSimple():Boolean[1]
{
   let result = execute(|Person.all()->sortBy(#/Person/lastName#), simpleRelationalMapping, testRuntime(), meta::relational::extension::relationalExtensions());
   assertSize($result.values, 12);
   assertEquals(['Allen', 'Firm B', 'Harris', 'Hill', 'Hill', 'Johnson', 'New York', 'Roberts', 'Smith', 'Smith', 'York', 'no Firm'], $result.values.lastName);
   assertEquals('select "root".ID as "pk_0", "root".FIRSTNAME as "firstName", "root".AGE as "age", "root".LASTNAME as "lastName", "root".LASTNAME as "o_lastName" from personTable as "root" order by "root".LASTNAME', $result->sqlRemoveFormatting());
}

function <<test.Test>> meta::relational::tests::query::sort::testSortByLambdaSimple():Boolean[1]
{
   let result = execute(|Person.all()->sortBy(p | $p.lastName), simpleRelationalMapping, testRuntime(), meta::relational::extension::relationalExtensions());
   assertSize($result.values, 12);
   assertEquals(['Allen', 'Firm B', 'Harris', 'Hill', 'Hill', 'Johnson', 'New York', 'Roberts', 'Smith', 'Smith', 'York', 'no Firm'], $result.values.lastName);
   assertEquals('select "root".ID as "pk_0", "root".FIRSTNAME as "firstName", "root".AGE as "age", "root".LASTNAME as "lastName" from personTable as "root" order by "root".LASTNAME', $result->sqlRemoveFormatting());
}

function <<test.Test>> meta::relational::tests::query::sort::testSortByLambdaMultiple():Boolean[1]
{
   let result = execute(|Person.all()->sortBy(p | $p.lastName)->sortBy(p | $p.firstName), simpleRelationalMapping, testRuntime(), meta::relational::extension::relationalExtensions());
   assertSize($result.values, 12);
   assertEquals(['Anthony Allen', 'Elena Firm B', 'David Harris', 'John Hill', 'Oliver Hill', 'John Johnson', 'Don New York', 'Fabrice Roberts', 'No address Smith', 'Peter Smith', 'New York', 'No firm no Firm'], zip($result.values.firstName, $result.values.lastName)->map(pair | $pair.first + ' ' + $pair.second));
   assertEquals('select "root".ID as "pk_0", "root".FIRSTNAME as "firstName", "root".AGE as "age", "root".LASTNAME as "lastName" from personTable as "root" order by "root".LASTNAME,"root".FIRSTNAME', $result->sqlRemoveFormatting());
}

function <<test.Test>> meta::relational::tests::query::sort::testSortByLambdaMultipleComplex():Boolean[1]
{
   let result = execute(|Person.all()->sortBy(p | if($p.age >= 50, | 50, |if($p.age >= 30, | 30, | 20)))->sortBy(p | $p.fullName(true)), simpleRelationalMapping, testRuntime(), meta::relational::extension::relationalExtensions());
   assertSize($result.values, 12);
   assertEquals(['22 Allen Anthony', '12 Hill John', '22 Johnson John', '23 Smith Peter', '35 Firm B Elena', '35 Harris David', '32 Hill Oliver', '35 New York Don', '34 Roberts Fabrice', '35 Smith No address', '35 York New', '35 no Firm No firm'], zip($result.values.age, zip($result.values.lastName, $result.values.firstName))->map(pair | $pair.first->toString() + ' ' + $pair.second.first + ' ' + $pair.second.second));
   assertEquals('select "root".ID as "pk_0", "root".FIRSTNAME as "firstName", "root".AGE as "age", "root".LASTNAME as "lastName" from personTable as "root" order by case when ("root".AGE is not null and "root".AGE >= 50) then 50 else case when ("root".AGE is not null and "root".AGE >= 30) then 30 else 20 end end,case when true then concat("root".LASTNAME, \', \', "root".FIRSTNAME) else concat("root".FIRSTNAME, \' \', "root".LASTNAME) end', $result->sqlRemoveFormatting());
}

function <<test.Test>> meta::relational::tests::query::sort::testSortByLambdaColumnAddition():Boolean[1]
{
   let result = execute(|Person.all()->sortBy(p | $p.lastName + '|' + $p.firstName), simpleRelationalMapping, testRuntime(), meta::relational::extension::relationalExtensions());
   assertSize($result.values, 12);
   assertEquals(['Allen|Anthony', 'Firm B|Elena', 'Harris|David', 'Hill|John', 'Hill|Oliver', 'Johnson|John', 'New York|Don', 'Roberts|Fabrice', 'Smith|No address', 'Smith|Peter', 'York|New', 'no Firm|No firm'], zip($result.values.lastName, $result.values.firstName)->map(pair | $pair.first + '|' + $pair.second));
   assertEquals('select "root".ID as "pk_0", "root".FIRSTNAME as "firstName", "root".AGE as "age", "root".LASTNAME as "lastName" from personTable as "root" order by concat("root".LASTNAME, \'|\', "root".FIRSTNAME)', $result->sqlRemoveFormatting());
}

function <<test.Test>> meta::relational::tests::query::sort::testSortByLambdaWithIfElseValue():Boolean[1]
{
   let result = execute(|Person.all()->filter(p|$p.lastName == 'Hill' || $p.firstName == 'John')->sortBy(p | if($p.lastName == 'Hill' && $p.firstName == 'John', | 0, |if ($p.lastName == 'Hill' || $p.firstName == 'John', | 10, | 20))), simpleRelationalMapping, testRuntime(), meta::relational::extension::relationalExtensions());
   assertSize($result.values, 3);
   assertEquals(['John Hill', 'John Johnson', 'Oliver Hill'], zip($result.values.firstName, $result.values.lastName)->map(pair | $pair.first + ' ' + $pair.second));
   assertEquals('select "root".ID as "pk_0", "root".FIRSTNAME as "firstName", "root".AGE as "age", "root".LASTNAME as "lastName" from personTable as "root" where ("root".LASTNAME = \'Hill\' or "root".FIRSTNAME = \'John\') order by case when ("root".LASTNAME = \'Hill\' and "root".FIRSTNAME = \'John\') then 0 else case when ("root".LASTNAME = \'Hill\' or "root".FIRSTNAME = \'John\') then 10 else 20 end end', $result->sqlRemoveFormatting());
}

function <<test.Test>> meta::relational::tests::query::sort::testSortByLambdaWIthIfElseColumn():Boolean[1]
{
   let result = execute(|Person.all()->filter(p|$p.lastName == 'Hill' || $p.firstName == 'John')->sortBy(p | if($p.lastName == 'Hill', |$p.lastName, |$p.firstName)), simpleRelationalMapping, testRuntime(), meta::relational::extension::relationalExtensions());
   assertSize($result.values, 3);
   assertEquals(['John Hill', 'Oliver Hill', 'John Johnson'], zip($result.values.firstName, $result.values.lastName)->map(pair | $pair.first + ' ' + $pair.second));
   assertEquals('select "root".ID as "pk_0", "root".FIRSTNAME as "firstName", "root".AGE as "age", "root".LASTNAME as "lastName" from personTable as "root" where ("root".LASTNAME = \'Hill\' or "root".FIRSTNAME = \'John\') order by case when "root".LASTNAME = \'Hill\' then "root".LASTNAME else "root".FIRSTNAME end', $result->sqlRemoveFormatting());
}

function <<test.Test>> meta::relational::tests::query::sort::testSortByLambdaDeepOptional():Boolean[1]
{
   let result = execute(|Person.all()->sortBy(p | $p.address->toOne().name), simpleRelationalMapping, testRuntime(), meta::relational::extension::relationalExtensions());
   assertSize($result.values, 12);
   assertEquals(['Hoboken', 'Hong Kong', 'New York', 'New York', 'New York', 'New York', 'New York', 'New York', 'New York', 'New York', 'San Fransisco'], $result.values.address.name);
   assertEquals(['No address', 'Peter', 'Oliver', 'John', 'John', 'Anthony', 'David', 'No firm', 'New', 'Elena', 'Don', 'Fabrice'], $result.values.firstName);
   assertEquals('select "root".ID as "pk_0", "root".FIRSTNAME as "firstName", "root".AGE as "age", "root".LASTNAME as "lastName" from personTable as "root" left outer join addressTable as "addresstable_0" on ("addresstable_0".ID = "root".ADDRESSID) order by "addresstable_0".NAME', $result->sqlRemoveFormatting());
}

function <<test.Test>> meta::relational::tests::query::sort::testSortByLambdaAndGraphFetch():Boolean[1]
{
   let rawPlan = meta::pure::executionPlan::executionPlan(|Person.all()->sortBy(p | $p.address->toOne().name)
                                      ->graphFetch(
                                        #{
                                          Person{
                                            firstName,
                                            address {
                                              name
                                            }
                                          }
                                        }#
                                      )->serialize(
                                        #{
                                          Person{
                                            firstName,
                                            address {
                                              name
                                            }
                                          }
                                        }#
                                      ), 
                                      simpleRelationalMapping, testRuntime(), meta::relational::extension::relationalExtensions());
  assertEquals( 'PureExp\n' +
                '(\n' +
                '  type = String\n' +
                '  expression =  -> serialize(#{meta::relational::tests::model::simple::Person {firstName, address {name}}}#)\n' +
                '  (\n' +
                '    StoreMappingGlobalGraphFetch\n' +
                '    (\n' +
                '      type = PartialClass[impls=[(meta::relational::tests::model::simple::Person | simpleRelationalMappingInc.meta_relational_tests_model_simple_Person)], propertiesWithParameters = [address, firstName]]\n' +
                '      resultSizeRange = *\n' +
                '      store = meta::relational::tests::db\n' +
                '      localGraphFetchExecutionNode = \n' +
                '         RelationalGraphFetch\n' +
                '         (\n' +
                '           type = PartialClass[impls=[(meta::relational::tests::model::simple::Person | simpleRelationalMappingInc.meta_relational_tests_model_simple_Person)], propertiesWithParameters = [address, firstName]]\n' +
                '           nodeIndex = 0\n' +
                '           relationalNode = \n' +
                '              SQL\n' +
                '              (\n' +
                '                type = meta::pure::metamodel::type::Any\n' +
                '                resultColumns = [("pk_0", INT), ("firstName", VARCHAR(200))]\n' +
                '                sql = select "root".ID as "pk_0", "root".FIRSTNAME as "firstName" from personTable as "root" left outer join addressTable as "addresstable_0" on ("addresstable_0".ID = "root".ADDRESSID) order by "addresstable_0".NAME\n' +
                '                connection = TestDatabaseConnection(type = "H2")\n' +
                '              )\n' +
                '           children = [\n' +
                '              RelationalGraphFetch\n' +
                '              (\n' +
                '                type = PartialClass[impls=[(meta::relational::tests::model::simple::Address | simpleRelationalMappingInc.meta_relational_tests_model_simple_Address)], propertiesWithParameters = [name]]\n' +
                '                nodeIndex = 2\n' +
                '                relationalNode = \n' +
                '                   SQL\n' +
                '                   (\n' +
                '                     type = meta::pure::metamodel::type::Any\n' +
                '                     resultColumns = [("parent_key_gen_0", INT), ("pk_0", INT), ("name", VARCHAR(200))]\n' +
                '                     sql = select distinct "temp_table_node_0_0".pk_0 as "parent_key_gen_0", "addresstable_0".ID as "pk_0", "addresstable_0".NAME as "name" from (select * from (${temp_table_node_0}) as "root") as "temp_table_node_0_0" inner join personTable as "root" on ("temp_table_node_0_0".pk_0 = "root".ID) left outer join addressTable as "addresstable_0" on ("addresstable_0".ID = "root".ADDRESSID) where "addresstable_0".ID is not null\n' +
                '                     connection = TestDatabaseConnection(type = "H2")\n' +
                '                   )\n' +
                '                children = [\n' +
                '                   \n' +
                '                ]\n' +
                '              )\n' +
                '\n' +
                '           ]\n' +
                '         )\n' +
                '      children = [\n' +
                '         \n' +
                '      ]\n' +
                '      localTreeIndices = [0, 1, 2, 3]\n' +
                '      dependencyIndices = []\n' +
                '    )\n' +
                '  )\n' +
                ')\n',$rawPlan->planToString(meta::relational::extension::relationalExtensions()));
}

function <<test.Test, test.AlloyOnly>> meta::relational::tests::query::sort::alloy::testSortByLambdaAndGraphFetchDeep():Boolean[1]
{
   let gft = #{
                Person{
                  firstName,
                  address
                  {
                    name
                  }
                }
              }#;
   let result = execute(|Person.all()->sortBy(
                                        p | $p.address->toOne().name
                                      )->graphFetch(
                                        $gft
                                      )->serialize(
                                        $gft
                                      ), 
                                      simpleRelationalMapping, testRuntime(), meta::relational::extension::relationalExtensions());
   
   assertJsonStringsEqual('[{"firstName":"No address","address":null},{"firstName":"Peter","address":{"name":"Hoboken"}},{"firstName":"Oliver","address":{"name":"Hong Kong"}},{"firstName":"John","address":{"name":"New York"}},{"firstName":"John","address":{"name":"New York"}},{"firstName":"Anthony","address":{"name":"New York"}},{"firstName":"David","address":{"name":"New York"}},{"firstName":"No firm","address":{"name":"New York"}},{"firstName":"New","address":{"name":"New York"}},{"firstName":"Elena","address":{"name":"New York"}},{"firstName":"Don","address":{"name":"New York"}},{"firstName":"Fabrice","address":{"name":"San Fransisco"}}]', $result.values);
}


function <<test.Test>> meta::relational::tests::query::sort::testSortByLambda_QueryWithParameters_Plan():Boolean[1]
{
   let rawPlan = meta::pure::executionPlan::executionPlan({firstName: String[1], lastName: String[1]|Person.all()->filter(p|$p.lastName == $lastName || $p.firstName == $firstName)->sortBy(p | if($p.firstName == $firstName && $p.lastName == $lastName, | 0, |if ($p.lastName == $lastName || $p.firstName == $firstName, | 10, | 20)))}, simpleRelationalMapping, testRuntime(), meta::relational::extension::relationalExtensions());
   assertEquals('Sequence\n' +
                '(\n' +
                '  type = Class[impls=(meta::relational::tests::model::simple::Person | simpleRelationalMappingInc.meta_relational_tests_model_simple_Person)]\n' +
                '  resultSizeRange = *\n' +
                '  (\n' +
                '    FunctionParametersValidationNode\n' +
                '    (\n' +
                '      functionParameters = [firstName:String[1], lastName:String[1]]\n' +
                '    )\n' +
                '    Relational\n' +
                '    (\n' +
                '      type = Class[impls=(meta::relational::tests::model::simple::Person | simpleRelationalMappingInc.meta_relational_tests_model_simple_Person)]\n' +
                '      resultSizeRange = *\n' +
                '      resultColumns = [("pk_0", INT), ("firstName", VARCHAR(200)), ("age", INT), ("lastName", VARCHAR(200))]\n' +
                '      sql = select "root".ID as "pk_0", "root".FIRSTNAME as "firstName", "root".AGE as "age", "root".LASTNAME as "lastName" from personTable as "root" where ("root".LASTNAME = \'${lastName?replace("\'", "\'\'")}\' or "root".FIRSTNAME = \'${firstName?replace("\'", "\'\'")}\') order by case when ("root".FIRSTNAME = \'${firstName?replace("\'", "\'\'")}\' and "root".LASTNAME = \'${lastName?replace("\'", "\'\'")}\') then 0 else case when ("root".LASTNAME = \'${lastName?replace("\'", "\'\'")}\' or "root".FIRSTNAME = \'${firstName?replace("\'", "\'\'")}\') then 10 else 20 end end\n' +
                '      connection = TestDatabaseConnection(type = "H2")\n' +
                '    )\n' +
                '  )\n' +
                ')\n',$rawPlan->planToString(meta::relational::extension::relationalExtensions()));
}
